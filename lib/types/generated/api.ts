/* tslint:disable */
/* eslint-disable */
/**
 * HelpHut Food Rescue Management
 * Centralized platform for coordinating food donations, volunteers, and partner organizations. Aligns with the HelpHut mission to efficiently rescue food in Austin, reduce waste, and help those in need. This specification is maintained under a TDD approach, with auto-generated tests ensuring coverage of each endpoint. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityLog
 */
export interface ActivityLog {
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'table_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'record_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'old_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'new_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface Donation
 */
export interface Donation {
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'donor_id': string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'food_type_id': string;
    /**
     * 
     * @type {number}
     * @memberof Donation
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'unit': string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'storage_requirements'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Donation
     */
    'requires_refrigeration'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Donation
     */
    'requires_freezing'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Donation
     */
    'is_fragile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Donation
     */
    'requires_heavy_lifting'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'pickup_window_start': string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'pickup_window_end': string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'donated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface DonationCreate
 */
export interface DonationCreate {
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'donor_id': string;
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'food_type_id': string;
    /**
     * 
     * @type {number}
     * @memberof DonationCreate
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'unit': string;
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'storage_requirements'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DonationCreate
     */
    'requires_refrigeration'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DonationCreate
     */
    'requires_freezing'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DonationCreate
     */
    'is_fragile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DonationCreate
     */
    'requires_heavy_lifting'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'pickup_window_start': string;
    /**
     * 
     * @type {string}
     * @memberof DonationCreate
     */
    'pickup_window_end': string;
}
/**
 * 
 * @export
 * @interface DonationUpdate
 */
export interface DonationUpdate {
    /**
     * 
     * @type {string}
     * @memberof DonationUpdate
     */
    'food_type_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof DonationUpdate
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof DonationUpdate
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonationUpdate
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonationUpdate
     */
    'storage_requirements'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DonationUpdate
     */
    'requires_refrigeration'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DonationUpdate
     */
    'requires_freezing'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DonationUpdate
     */
    'is_fragile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DonationUpdate
     */
    'requires_heavy_lifting'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DonationUpdate
     */
    'pickup_window_start'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonationUpdate
     */
    'pickup_window_end'?: string;
}
/**
 * 
 * @export
 * @interface Donor
 */
export interface Donor {
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'contact_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'contact_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'business_hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'pickup_preferences'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Donor
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface DonorCreate
 */
export interface DonorCreate {
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'contact_email': string;
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'contact_phone': string;
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'business_hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'pickup_preferences'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorCreate
     */
    'location_id'?: string;
}
/**
 * 
 * @export
 * @interface DonorUpdate
 */
export interface DonorUpdate {
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'contact_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'contact_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'business_hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'pickup_preferences'?: string;
    /**
     * 
     * @type {string}
     * @memberof DonorUpdate
     */
    'location_id'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FoodType
 */
export interface FoodType {
    /**
     * 
     * @type {string}
     * @memberof FoodType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FoodType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FoodType
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FoodType
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface FoodTypeCreate
 */
export interface FoodTypeCreate {
    /**
     * 
     * @type {string}
     * @memberof FoodTypeCreate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface FoodTypeUpdate
 */
export interface FoodTypeUpdate {
    /**
     * 
     * @type {string}
     * @memberof FoodTypeUpdate
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface InventoryItem
 */
export interface InventoryItem {
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'donation_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'food_type_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InventoryItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'partner_org_id'?: string;
    /**
     * 
     * @type {InventoryStatus}
     * @memberof InventoryItem
     */
    'status'?: InventoryStatus;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface InventoryItemCreate
 */
export interface InventoryItemCreate {
    /**
     * 
     * @type {string}
     * @memberof InventoryItemCreate
     */
    'donation_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemCreate
     */
    'food_type_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InventoryItemCreate
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemCreate
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemCreate
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemCreate
     */
    'partner_org_id'?: string;
    /**
     * 
     * @type {InventoryStatus}
     * @memberof InventoryItemCreate
     */
    'status'?: InventoryStatus;
}


/**
 * 
 * @export
 * @interface InventoryItemUpdate
 */
export interface InventoryItemUpdate {
    /**
     * 
     * @type {string}
     * @memberof InventoryItemUpdate
     */
    'donation_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemUpdate
     */
    'food_type_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InventoryItemUpdate
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemUpdate
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemUpdate
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItemUpdate
     */
    'partner_org_id'?: string;
    /**
     * 
     * @type {InventoryStatus}
     * @memberof InventoryItemUpdate
     */
    'status'?: InventoryStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const InventoryStatus = {
    Available: 'Available',
    Reserved: 'Reserved',
    Distributed: 'Distributed'
} as const;

export type InventoryStatus = typeof InventoryStatus[keyof typeof InventoryStatus];


/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'zip'?: string;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface LocationCreate
 */
export interface LocationCreate {
    /**
     * 
     * @type {string}
     * @memberof LocationCreate
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCreate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCreate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCreate
     */
    'zip'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationCreate
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationCreate
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface LocationUpdate
 */
export interface LocationUpdate {
    /**
     * 
     * @type {string}
     * @memberof LocationUpdate
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationUpdate
     */
    'zip'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationUpdate
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationUpdate
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface Partner
 */
export interface Partner {
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Partner
     */
    'max_capacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Partner
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'contact_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'contact_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PartnerCreate
 */
export interface PartnerCreate {
    /**
     * 
     * @type {string}
     * @memberof PartnerCreate
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartnerCreate
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PartnerCreate
     */
    'max_capacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartnerCreate
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartnerCreate
     */
    'contact_email': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerCreate
     */
    'contact_phone': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerCreate
     */
    'location_id'?: string;
}
/**
 * 
 * @export
 * @interface PartnerUpdate
 */
export interface PartnerUpdate {
    /**
     * 
     * @type {string}
     * @memberof PartnerUpdate
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartnerUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PartnerUpdate
     */
    'max_capacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartnerUpdate
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartnerUpdate
     */
    'contact_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartnerUpdate
     */
    'contact_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartnerUpdate
     */
    'location_id'?: string;
}
/**
 * 
 * @export
 * @interface Shift
 */
export interface Shift {
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'shift_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shift
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ShiftCreate
 */
export interface ShiftCreate {
    /**
     * 
     * @type {string}
     * @memberof ShiftCreate
     */
    'volunteer_id': string;
    /**
     * 
     * @type {string}
     * @memberof ShiftCreate
     */
    'shift_date': string;
    /**
     * 
     * @type {string}
     * @memberof ShiftCreate
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ShiftCreate
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface ShiftUpdate
 */
export interface ShiftUpdate {
    /**
     * 
     * @type {string}
     * @memberof ShiftUpdate
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShiftUpdate
     */
    'shift_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShiftUpdate
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShiftUpdate
     */
    'end_time'?: string;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'donation_id'?: string;
    /**
     * 
     * @type {TicketStatus}
     * @memberof Ticket
     */
    'status'?: TicketStatus;
    /**
     * 
     * @type {TicketPriority}
     * @memberof Ticket
     */
    'priority'?: TicketPriority;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'partner_org_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'pickup_location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'dropoff_location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface TicketAttachment
 */
export interface TicketAttachment {
    /**
     * 
     * @type {string}
     * @memberof TicketAttachment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketAttachment
     */
    'ticket_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketAttachment
     */
    'attachment'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketAttachment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketAttachment
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TicketAttachmentCreate
 */
export interface TicketAttachmentCreate {
    /**
     * 
     * @type {string}
     * @memberof TicketAttachmentCreate
     */
    'ticket_id': string;
    /**
     * 
     * @type {string}
     * @memberof TicketAttachmentCreate
     */
    'attachment': string;
}
/**
 * 
 * @export
 * @interface TicketAttachmentUpdate
 */
export interface TicketAttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof TicketAttachmentUpdate
     */
    'ticket_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketAttachmentUpdate
     */
    'attachment'?: string;
}
/**
 * 
 * @export
 * @interface TicketCreate
 */
export interface TicketCreate {
    /**
     * 
     * @type {string}
     * @memberof TicketCreate
     */
    'donation_id'?: string;
    /**
     * 
     * @type {TicketStatus}
     * @memberof TicketCreate
     */
    'status'?: TicketStatus;
    /**
     * 
     * @type {TicketPriority}
     * @memberof TicketCreate
     */
    'priority'?: TicketPriority;
    /**
     * 
     * @type {string}
     * @memberof TicketCreate
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketCreate
     */
    'partner_org_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketCreate
     */
    'pickup_location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketCreate
     */
    'dropoff_location_id'?: string;
}


/**
 * 
 * @export
 * @interface TicketNote
 */
export interface TicketNote {
    /**
     * 
     * @type {string}
     * @memberof TicketNote
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketNote
     */
    'ticket_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketNote
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketNote
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketNote
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TicketNoteCreate
 */
export interface TicketNoteCreate {
    /**
     * 
     * @type {string}
     * @memberof TicketNoteCreate
     */
    'ticket_id': string;
    /**
     * 
     * @type {string}
     * @memberof TicketNoteCreate
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface TicketNoteUpdate
 */
export interface TicketNoteUpdate {
    /**
     * 
     * @type {string}
     * @memberof TicketNoteUpdate
     */
    'ticket_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketNoteUpdate
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TicketPriority = {
    Urgent: 'Urgent',
    Routine: 'Routine'
} as const;

export type TicketPriority = typeof TicketPriority[keyof typeof TicketPriority];


/**
 * 
 * @export
 * @enum {string}
 */

export const TicketStatus = {
    Submitted: 'Submitted',
    Scheduled: 'Scheduled',
    InTransit: 'InTransit',
    Delivered: 'Delivered',
    Completed: 'Completed'
} as const;

export type TicketStatus = typeof TicketStatus[keyof typeof TicketStatus];


/**
 * 
 * @export
 * @interface TicketTag
 */
export interface TicketTag {
    /**
     * 
     * @type {string}
     * @memberof TicketTag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTag
     */
    'ticket_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTag
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTag
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTag
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TicketTagCreate
 */
export interface TicketTagCreate {
    /**
     * 
     * @type {string}
     * @memberof TicketTagCreate
     */
    'ticket_id': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTagCreate
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface TicketTagUpdate
 */
export interface TicketTagUpdate {
    /**
     * 
     * @type {string}
     * @memberof TicketTagUpdate
     */
    'ticket_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTagUpdate
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface TicketUpdate
 */
export interface TicketUpdate {
    /**
     * 
     * @type {string}
     * @memberof TicketUpdate
     */
    'donation_id'?: string;
    /**
     * 
     * @type {TicketStatus}
     * @memberof TicketUpdate
     */
    'status'?: TicketStatus;
    /**
     * 
     * @type {TicketPriority}
     * @memberof TicketUpdate
     */
    'priority'?: TicketPriority;
    /**
     * 
     * @type {string}
     * @memberof TicketUpdate
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketUpdate
     */
    'partner_org_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketUpdate
     */
    'pickup_location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketUpdate
     */
    'dropoff_location_id'?: string;
}


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof User
     */
    'role'?: UserRole;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'hashed_password': string;
    /**
     * 
     * @type {UserRole}
     * @memberof UserCreate
     */
    'role': UserRole;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserRole = {
    Admin: 'Admin',
    Donor: 'Donor',
    Volunteer: 'Volunteer',
    Partner: 'Partner'
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];


/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'hashed_password'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof UserUpdate
     */
    'role'?: UserRole;
}


/**
 * 
 * @export
 * @interface Volunteer
 */
export interface Volunteer {
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'vehicle_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volunteer
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerAvailabilityTime
 */
export interface VolunteerAvailabilityTime {
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTime
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTime
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolunteerAvailabilityTime
     */
    'day_of_week'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTime
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTime
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTime
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTime
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerAvailabilityTimeCreate
 */
export interface VolunteerAvailabilityTimeCreate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTimeCreate
     */
    'volunteer_id': string;
    /**
     * 
     * @type {number}
     * @memberof VolunteerAvailabilityTimeCreate
     */
    'day_of_week': number;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTimeCreate
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTimeCreate
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface VolunteerAvailabilityTimeUpdate
 */
export interface VolunteerAvailabilityTimeUpdate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTimeUpdate
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolunteerAvailabilityTimeUpdate
     */
    'day_of_week'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTimeUpdate
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityTimeUpdate
     */
    'end_time'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerAvailabilityZone
 */
export interface VolunteerAvailabilityZone {
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZone
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZone
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZone
     */
    'zone'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZone
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZone
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerAvailabilityZoneCreate
 */
export interface VolunteerAvailabilityZoneCreate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZoneCreate
     */
    'volunteer_id': string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZoneCreate
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface VolunteerAvailabilityZoneUpdate
 */
export interface VolunteerAvailabilityZoneUpdate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZoneUpdate
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerAvailabilityZoneUpdate
     */
    'zone'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerCreate
 */
export interface VolunteerCreate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerCreate
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerCreate
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerCreate
     */
    'vehicle_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerCreate
     */
    'location_id'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerSkill
 */
export interface VolunteerSkill {
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkill
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkill
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkill
     */
    'skill'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkill
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkill
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerSkillCreate
 */
export interface VolunteerSkillCreate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkillCreate
     */
    'volunteer_id': string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkillCreate
     */
    'skill': string;
}
/**
 * 
 * @export
 * @interface VolunteerSkillUpdate
 */
export interface VolunteerSkillUpdate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkillUpdate
     */
    'volunteer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerSkillUpdate
     */
    'skill'?: string;
}
/**
 * 
 * @export
 * @interface VolunteerUpdate
 */
export interface VolunteerUpdate {
    /**
     * 
     * @type {string}
     * @memberof VolunteerUpdate
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerUpdate
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerUpdate
     */
    'vehicle_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolunteerUpdate
     */
    'location_id'?: string;
}

/**
 * ActivityLogsApi - axios parameter creator
 * @export
 */
export const ActivityLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List activity logs
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityLogs: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity-logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogsApi - functional programming interface
 * @export
 */
export const ActivityLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List activity logs
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivityLogs(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivityLogs(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogsApi.listActivityLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityLogsApi - factory interface
 * @export
 */
export const ActivityLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary List activity logs
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityLogs(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityLog>> {
            return localVarFp.listActivityLogs(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityLogsApi - object-oriented interface
 * @export
 * @class ActivityLogsApi
 * @extends {BaseAPI}
 */
export class ActivityLogsApi extends BaseAPI {
    /**
     * 
     * @summary List activity logs
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogsApi
     */
    public listActivityLogs(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ActivityLogsApiFp(this.configuration).listActivityLogs(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DonationsApi - axios parameter creator
 * @export
 */
export const DonationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new donation
         * @param {DonationCreate} donationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonation: async (donationCreate: DonationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'donationCreate' is not null or undefined
            assertParamExists('createDonation', 'donationCreate', donationCreate)
            const localVarPath = `/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new donation for a specific donor
         * @param {string} donorId UUID of the donor
         * @param {DonationCreate} donationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonationForDonor: async (donorId: string, donationCreate: DonationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'donorId' is not null or undefined
            assertParamExists('createDonationForDonor', 'donorId', donorId)
            // verify required parameter 'donationCreate' is not null or undefined
            assertParamExists('createDonationForDonor', 'donationCreate', donationCreate)
            const localVarPath = `/donors/{donorId}/donations`
                .replace(`{${"donorId"}}`, encodeURIComponent(String(donorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a donation by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDonation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDonation', 'id', id)
            const localVarPath = `/donations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a donation by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDonation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDonation', 'id', id)
            const localVarPath = `/donations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List donations
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDonations: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all donations for a specific donor
         * @param {string} donorId UUID of the donor
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDonationsByDonor: async (donorId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'donorId' is not null or undefined
            assertParamExists('listDonationsByDonor', 'donorId', donorId)
            const localVarPath = `/donors/{donorId}/donations`
                .replace(`{${"donorId"}}`, encodeURIComponent(String(donorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a donation by ID
         * @param {string} id UUID of the resource
         * @param {DonationUpdate} donationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDonation: async (id: string, donationUpdate: DonationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDonation', 'id', id)
            // verify required parameter 'donationUpdate' is not null or undefined
            assertParamExists('updateDonation', 'donationUpdate', donationUpdate)
            const localVarPath = `/donations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DonationsApi - functional programming interface
 * @export
 */
export const DonationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DonationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new donation
         * @param {DonationCreate} donationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDonation(donationCreate: DonationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDonation(donationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.createDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new donation for a specific donor
         * @param {string} donorId UUID of the donor
         * @param {DonationCreate} donationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDonationForDonor(donorId: string, donationCreate: DonationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDonationForDonor(donorId, donationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.createDonationForDonor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a donation by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDonation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDonation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.deleteDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a donation by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDonation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDonation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.getDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List donations
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDonations(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Donation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDonations(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.listDonations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all donations for a specific donor
         * @param {string} donorId UUID of the donor
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDonationsByDonor(donorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Donation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDonationsByDonor(donorId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.listDonationsByDonor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a donation by ID
         * @param {string} id UUID of the resource
         * @param {DonationUpdate} donationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDonation(id: string, donationUpdate: DonationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDonation(id, donationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationsApi.updateDonation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DonationsApi - factory interface
 * @export
 */
export const DonationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DonationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new donation
         * @param {DonationCreate} donationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonation(donationCreate: DonationCreate, options?: RawAxiosRequestConfig): AxiosPromise<Donation> {
            return localVarFp.createDonation(donationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new donation for a specific donor
         * @param {string} donorId UUID of the donor
         * @param {DonationCreate} donationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonationForDonor(donorId: string, donationCreate: DonationCreate, options?: RawAxiosRequestConfig): AxiosPromise<Donation> {
            return localVarFp.createDonationForDonor(donorId, donationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a donation by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDonation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDonation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a donation by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDonation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Donation> {
            return localVarFp.getDonation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List donations
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDonations(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Donation>> {
            return localVarFp.listDonations(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all donations for a specific donor
         * @param {string} donorId UUID of the donor
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDonationsByDonor(donorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Donation>> {
            return localVarFp.listDonationsByDonor(donorId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a donation by ID
         * @param {string} id UUID of the resource
         * @param {DonationUpdate} donationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDonation(id: string, donationUpdate: DonationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Donation> {
            return localVarFp.updateDonation(id, donationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DonationsApi - object-oriented interface
 * @export
 * @class DonationsApi
 * @extends {BaseAPI}
 */
export class DonationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new donation
     * @param {DonationCreate} donationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public createDonation(donationCreate: DonationCreate, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).createDonation(donationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new donation for a specific donor
     * @param {string} donorId UUID of the donor
     * @param {DonationCreate} donationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public createDonationForDonor(donorId: string, donationCreate: DonationCreate, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).createDonationForDonor(donorId, donationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a donation by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public deleteDonation(id: string, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).deleteDonation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a donation by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public getDonation(id: string, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).getDonation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List donations
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public listDonations(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).listDonations(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all donations for a specific donor
     * @param {string} donorId UUID of the donor
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public listDonationsByDonor(donorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).listDonationsByDonor(donorId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a donation by ID
     * @param {string} id UUID of the resource
     * @param {DonationUpdate} donationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public updateDonation(id: string, donationUpdate: DonationUpdate, options?: RawAxiosRequestConfig) {
        return DonationsApiFp(this.configuration).updateDonation(id, donationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DonorsApi - axios parameter creator
 * @export
 */
export const DonorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new donor
         * @param {DonorCreate} donorCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonor: async (donorCreate: DonorCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'donorCreate' is not null or undefined
            assertParamExists('createDonor', 'donorCreate', donorCreate)
            const localVarPath = `/donors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donorCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a donor by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDonor: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDonor', 'id', id)
            const localVarPath = `/donors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a donor by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDonor: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDonor', 'id', id)
            const localVarPath = `/donors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List donors
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDonors: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/donors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a donor by ID
         * @param {string} id UUID of the resource
         * @param {DonorUpdate} donorUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDonor: async (id: string, donorUpdate: DonorUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDonor', 'id', id)
            // verify required parameter 'donorUpdate' is not null or undefined
            assertParamExists('updateDonor', 'donorUpdate', donorUpdate)
            const localVarPath = `/donors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donorUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DonorsApi - functional programming interface
 * @export
 */
export const DonorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DonorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new donor
         * @param {DonorCreate} donorCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDonor(donorCreate: DonorCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDonor(donorCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonorsApi.createDonor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a donor by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDonor(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDonor(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonorsApi.deleteDonor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a donor by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDonor(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDonor(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonorsApi.getDonor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List donors
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDonors(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Donor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDonors(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonorsApi.listDonors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a donor by ID
         * @param {string} id UUID of the resource
         * @param {DonorUpdate} donorUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDonor(id: string, donorUpdate: DonorUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Donor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDonor(id, donorUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonorsApi.updateDonor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DonorsApi - factory interface
 * @export
 */
export const DonorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DonorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new donor
         * @param {DonorCreate} donorCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDonor(donorCreate: DonorCreate, options?: RawAxiosRequestConfig): AxiosPromise<Donor> {
            return localVarFp.createDonor(donorCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a donor by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDonor(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDonor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a donor by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDonor(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Donor> {
            return localVarFp.getDonor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List donors
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDonors(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Donor>> {
            return localVarFp.listDonors(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a donor by ID
         * @param {string} id UUID of the resource
         * @param {DonorUpdate} donorUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDonor(id: string, donorUpdate: DonorUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Donor> {
            return localVarFp.updateDonor(id, donorUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DonorsApi - object-oriented interface
 * @export
 * @class DonorsApi
 * @extends {BaseAPI}
 */
export class DonorsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new donor
     * @param {DonorCreate} donorCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorsApi
     */
    public createDonor(donorCreate: DonorCreate, options?: RawAxiosRequestConfig) {
        return DonorsApiFp(this.configuration).createDonor(donorCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a donor by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorsApi
     */
    public deleteDonor(id: string, options?: RawAxiosRequestConfig) {
        return DonorsApiFp(this.configuration).deleteDonor(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a donor by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorsApi
     */
    public getDonor(id: string, options?: RawAxiosRequestConfig) {
        return DonorsApiFp(this.configuration).getDonor(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List donors
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorsApi
     */
    public listDonors(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return DonorsApiFp(this.configuration).listDonors(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a donor by ID
     * @param {string} id UUID of the resource
     * @param {DonorUpdate} donorUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonorsApi
     */
    public updateDonor(id: string, donorUpdate: DonorUpdate, options?: RawAxiosRequestConfig) {
        return DonorsApiFp(this.configuration).updateDonor(id, donorUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodTypesApi - axios parameter creator
 * @export
 */
export const FoodTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new food type
         * @param {FoodTypeCreate} foodTypeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFoodType: async (foodTypeCreate: FoodTypeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodTypeCreate' is not null or undefined
            assertParamExists('createFoodType', 'foodTypeCreate', foodTypeCreate)
            const localVarPath = `/food-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodTypeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a food type by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFoodType: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFoodType', 'id', id)
            const localVarPath = `/food-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a food type by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFoodType: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFoodType', 'id', id)
            const localVarPath = `/food-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all food types
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodTypes: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/food-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a food type by ID
         * @param {string} id UUID of the resource
         * @param {FoodTypeUpdate} foodTypeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFoodType: async (id: string, foodTypeUpdate: FoodTypeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFoodType', 'id', id)
            // verify required parameter 'foodTypeUpdate' is not null or undefined
            assertParamExists('updateFoodType', 'foodTypeUpdate', foodTypeUpdate)
            const localVarPath = `/food-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodTypeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodTypesApi - functional programming interface
 * @export
 */
export const FoodTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new food type
         * @param {FoodTypeCreate} foodTypeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFoodType(foodTypeCreate: FoodTypeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFoodType(foodTypeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodTypesApi.createFoodType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a food type by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFoodType(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFoodType(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodTypesApi.deleteFoodType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a food type by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFoodType(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFoodType(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodTypesApi.getFoodType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all food types
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoodTypes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoodTypes(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodTypesApi.listFoodTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a food type by ID
         * @param {string} id UUID of the resource
         * @param {FoodTypeUpdate} foodTypeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFoodType(id: string, foodTypeUpdate: FoodTypeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFoodType(id, foodTypeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodTypesApi.updateFoodType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodTypesApi - factory interface
 * @export
 */
export const FoodTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodTypesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new food type
         * @param {FoodTypeCreate} foodTypeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFoodType(foodTypeCreate: FoodTypeCreate, options?: RawAxiosRequestConfig): AxiosPromise<FoodType> {
            return localVarFp.createFoodType(foodTypeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a food type by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFoodType(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFoodType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a food type by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFoodType(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FoodType> {
            return localVarFp.getFoodType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all food types
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodTypes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FoodType>> {
            return localVarFp.listFoodTypes(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a food type by ID
         * @param {string} id UUID of the resource
         * @param {FoodTypeUpdate} foodTypeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFoodType(id: string, foodTypeUpdate: FoodTypeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<FoodType> {
            return localVarFp.updateFoodType(id, foodTypeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodTypesApi - object-oriented interface
 * @export
 * @class FoodTypesApi
 * @extends {BaseAPI}
 */
export class FoodTypesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new food type
     * @param {FoodTypeCreate} foodTypeCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodTypesApi
     */
    public createFoodType(foodTypeCreate: FoodTypeCreate, options?: RawAxiosRequestConfig) {
        return FoodTypesApiFp(this.configuration).createFoodType(foodTypeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a food type by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodTypesApi
     */
    public deleteFoodType(id: string, options?: RawAxiosRequestConfig) {
        return FoodTypesApiFp(this.configuration).deleteFoodType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a food type by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodTypesApi
     */
    public getFoodType(id: string, options?: RawAxiosRequestConfig) {
        return FoodTypesApiFp(this.configuration).getFoodType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all food types
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodTypesApi
     */
    public listFoodTypes(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return FoodTypesApiFp(this.configuration).listFoodTypes(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a food type by ID
     * @param {string} id UUID of the resource
     * @param {FoodTypeUpdate} foodTypeUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodTypesApi
     */
    public updateFoodType(id: string, foodTypeUpdate: FoodTypeUpdate, options?: RawAxiosRequestConfig) {
        return FoodTypesApiFp(this.configuration).updateFoodType(id, foodTypeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an inventory item
         * @param {InventoryItemCreate} inventoryItemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInventoryItem: async (inventoryItemCreate: InventoryItemCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryItemCreate' is not null or undefined
            assertParamExists('createInventoryItem', 'inventoryItemCreate', inventoryItemCreate)
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inventoryItemCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an inventory item by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInventoryItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInventoryItem', 'id', id)
            const localVarPath = `/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve inventory item by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInventoryItem', 'id', id)
            const localVarPath = `/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List inventory items
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInventory: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an inventory item by ID
         * @param {string} id UUID of the resource
         * @param {InventoryItemUpdate} inventoryItemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryItem: async (id: string, inventoryItemUpdate: InventoryItemUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInventoryItem', 'id', id)
            // verify required parameter 'inventoryItemUpdate' is not null or undefined
            assertParamExists('updateInventoryItem', 'inventoryItemUpdate', inventoryItemUpdate)
            const localVarPath = `/inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inventoryItemUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an inventory item
         * @param {InventoryItemCreate} inventoryItemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInventoryItem(inventoryItemCreate: InventoryItemCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInventoryItem(inventoryItemCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.createInventoryItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an inventory item by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInventoryItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInventoryItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.deleteInventoryItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve inventory item by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventoryItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventoryItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getInventoryItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List inventory items
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInventory(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InventoryItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInventory(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.listInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an inventory item by ID
         * @param {string} id UUID of the resource
         * @param {InventoryItemUpdate} inventoryItemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInventoryItem(id: string, inventoryItemUpdate: InventoryItemUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInventoryItem(id, inventoryItemUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.updateInventoryItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an inventory item
         * @param {InventoryItemCreate} inventoryItemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInventoryItem(inventoryItemCreate: InventoryItemCreate, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItem> {
            return localVarFp.createInventoryItem(inventoryItemCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an inventory item by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInventoryItem(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteInventoryItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve inventory item by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryItem(id: string, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItem> {
            return localVarFp.getInventoryItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List inventory items
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInventory(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<InventoryItem>> {
            return localVarFp.listInventory(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an inventory item by ID
         * @param {string} id UUID of the resource
         * @param {InventoryItemUpdate} inventoryItemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryItem(id: string, inventoryItemUpdate: InventoryItemUpdate, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItem> {
            return localVarFp.updateInventoryItem(id, inventoryItemUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * 
     * @summary Create an inventory item
     * @param {InventoryItemCreate} inventoryItemCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public createInventoryItem(inventoryItemCreate: InventoryItemCreate, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).createInventoryItem(inventoryItemCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an inventory item by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public deleteInventoryItem(id: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).deleteInventoryItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve inventory item by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getInventoryItem(id: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getInventoryItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List inventory items
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public listInventory(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).listInventory(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an inventory item by ID
     * @param {string} id UUID of the resource
     * @param {InventoryItemUpdate} inventoryItemUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateInventoryItem(id: string, inventoryItemUpdate: InventoryItemUpdate, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).updateInventoryItem(id, inventoryItemUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new location
         * @param {LocationCreate} locationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocation: async (locationCreate: LocationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationCreate' is not null or undefined
            assertParamExists('createLocation', 'locationCreate', locationCreate)
            const localVarPath = `/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a location by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLocation', 'id', id)
            const localVarPath = `/locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a location by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLocation', 'id', id)
            const localVarPath = `/locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List locations
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLocations: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a location by ID
         * @param {string} id UUID of the resource
         * @param {LocationUpdate} locationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocation: async (id: string, locationUpdate: LocationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLocation', 'id', id)
            // verify required parameter 'locationUpdate' is not null or undefined
            assertParamExists('updateLocation', 'locationUpdate', locationUpdate)
            const localVarPath = `/locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new location
         * @param {LocationCreate} locationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLocation(locationCreate: LocationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLocation(locationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.createLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a location by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.deleteLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a location by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.getLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List locations
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLocations(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLocations(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.listLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a location by ID
         * @param {string} id UUID of the resource
         * @param {LocationUpdate} locationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLocation(id: string, locationUpdate: LocationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLocation(id, locationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.updateLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new location
         * @param {LocationCreate} locationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocation(locationCreate: LocationCreate, options?: RawAxiosRequestConfig): AxiosPromise<Location> {
            return localVarFp.createLocation(locationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a location by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLocation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a location by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Location> {
            return localVarFp.getLocation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List locations
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLocations(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Location>> {
            return localVarFp.listLocations(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a location by ID
         * @param {string} id UUID of the resource
         * @param {LocationUpdate} locationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocation(id: string, locationUpdate: LocationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Location> {
            return localVarFp.updateLocation(id, locationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new location
     * @param {LocationCreate} locationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public createLocation(locationCreate: LocationCreate, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).createLocation(locationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a location by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public deleteLocation(id: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).deleteLocation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a location by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public getLocation(id: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).getLocation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List locations
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public listLocations(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).listLocations(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a location by ID
     * @param {string} id UUID of the resource
     * @param {LocationUpdate} locationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public updateLocation(id: string, locationUpdate: LocationUpdate, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).updateLocation(id, locationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnersApi - axios parameter creator
 * @export
 */
export const PartnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new partner
         * @param {PartnerCreate} partnerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner: async (partnerCreate: PartnerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerCreate' is not null or undefined
            assertParamExists('createPartner', 'partnerCreate', partnerCreate)
            const localVarPath = `/partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a partner by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartner: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePartner', 'id', id)
            const localVarPath = `/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a partner by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPartner', 'id', id)
            const localVarPath = `/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List partners
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPartners: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a partner by ID
         * @param {string} id UUID of the resource
         * @param {PartnerUpdate} partnerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartner: async (id: string, partnerUpdate: PartnerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePartner', 'id', id)
            // verify required parameter 'partnerUpdate' is not null or undefined
            assertParamExists('updatePartner', 'partnerUpdate', partnerUpdate)
            const localVarPath = `/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnersApi - functional programming interface
 * @export
 */
export const PartnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new partner
         * @param {PartnerCreate} partnerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPartner(partnerCreate: PartnerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPartner(partnerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.createPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a partner by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePartner(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePartner(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.deletePartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a partner by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartner(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartner(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.getPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List partners
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPartners(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Partner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPartners(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.listPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a partner by ID
         * @param {string} id UUID of the resource
         * @param {PartnerUpdate} partnerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePartner(id: string, partnerUpdate: PartnerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePartner(id, partnerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.updatePartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnersApi - factory interface
 * @export
 */
export const PartnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new partner
         * @param {PartnerCreate} partnerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner(partnerCreate: PartnerCreate, options?: RawAxiosRequestConfig): AxiosPromise<Partner> {
            return localVarFp.createPartner(partnerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a partner by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartner(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePartner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a partner by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Partner> {
            return localVarFp.getPartner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List partners
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPartners(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Partner>> {
            return localVarFp.listPartners(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a partner by ID
         * @param {string} id UUID of the resource
         * @param {PartnerUpdate} partnerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartner(id: string, partnerUpdate: PartnerUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Partner> {
            return localVarFp.updatePartner(id, partnerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnersApi - object-oriented interface
 * @export
 * @class PartnersApi
 * @extends {BaseAPI}
 */
export class PartnersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new partner
     * @param {PartnerCreate} partnerCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public createPartner(partnerCreate: PartnerCreate, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).createPartner(partnerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a partner by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public deletePartner(id: string, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).deletePartner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a partner by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public getPartner(id: string, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).getPartner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List partners
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public listPartners(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).listPartners(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a partner by ID
     * @param {string} id UUID of the resource
     * @param {PartnerUpdate} partnerUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public updatePartner(id: string, partnerUpdate: PartnerUpdate, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).updatePartner(id, partnerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShiftsApi - axios parameter creator
 * @export
 */
export const ShiftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a shift
         * @param {ShiftCreate} shiftCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShift: async (shiftCreate: ShiftCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shiftCreate' is not null or undefined
            assertParamExists('createShift', 'shiftCreate', shiftCreate)
            const localVarPath = `/shifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shiftCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a shift by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShift: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteShift', 'id', id)
            const localVarPath = `/shifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a shift by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShift: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getShift', 'id', id)
            const localVarPath = `/shifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List shifts
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShifts: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a shift by ID
         * @param {string} id UUID of the resource
         * @param {ShiftUpdate} shiftUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShift: async (id: string, shiftUpdate: ShiftUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShift', 'id', id)
            // verify required parameter 'shiftUpdate' is not null or undefined
            assertParamExists('updateShift', 'shiftUpdate', shiftUpdate)
            const localVarPath = `/shifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shiftUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShiftsApi - functional programming interface
 * @export
 */
export const ShiftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShiftsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a shift
         * @param {ShiftCreate} shiftCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShift(shiftCreate: ShiftCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShift(shiftCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShiftsApi.createShift']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a shift by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShift(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShift(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShiftsApi.deleteShift']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a shift by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShift(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShift(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShiftsApi.getShift']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List shifts
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShifts(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Shift>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShifts(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShiftsApi.listShifts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a shift by ID
         * @param {string} id UUID of the resource
         * @param {ShiftUpdate} shiftUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShift(id: string, shiftUpdate: ShiftUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShift(id, shiftUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShiftsApi.updateShift']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShiftsApi - factory interface
 * @export
 */
export const ShiftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShiftsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a shift
         * @param {ShiftCreate} shiftCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShift(shiftCreate: ShiftCreate, options?: RawAxiosRequestConfig): AxiosPromise<Shift> {
            return localVarFp.createShift(shiftCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a shift by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShift(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a shift by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShift(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Shift> {
            return localVarFp.getShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List shifts
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShifts(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Shift>> {
            return localVarFp.listShifts(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a shift by ID
         * @param {string} id UUID of the resource
         * @param {ShiftUpdate} shiftUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShift(id: string, shiftUpdate: ShiftUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Shift> {
            return localVarFp.updateShift(id, shiftUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShiftsApi - object-oriented interface
 * @export
 * @class ShiftsApi
 * @extends {BaseAPI}
 */
export class ShiftsApi extends BaseAPI {
    /**
     * 
     * @summary Create a shift
     * @param {ShiftCreate} shiftCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftsApi
     */
    public createShift(shiftCreate: ShiftCreate, options?: RawAxiosRequestConfig) {
        return ShiftsApiFp(this.configuration).createShift(shiftCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a shift by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftsApi
     */
    public deleteShift(id: string, options?: RawAxiosRequestConfig) {
        return ShiftsApiFp(this.configuration).deleteShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a shift by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftsApi
     */
    public getShift(id: string, options?: RawAxiosRequestConfig) {
        return ShiftsApiFp(this.configuration).getShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List shifts
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftsApi
     */
    public listShifts(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ShiftsApiFp(this.configuration).listShifts(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a shift by ID
     * @param {string} id UUID of the resource
     * @param {ShiftUpdate} shiftUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftsApi
     */
    public updateShift(id: string, shiftUpdate: ShiftUpdate, options?: RawAxiosRequestConfig) {
        return ShiftsApiFp(this.configuration).updateShift(id, shiftUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketMetaApi - axios parameter creator
 * @export
 */
export const TicketMetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ticket attachment
         * @param {TicketAttachmentCreate} ticketAttachmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketAttachment: async (ticketAttachmentCreate: TicketAttachmentCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketAttachmentCreate' is not null or undefined
            assertParamExists('createTicketAttachment', 'ticketAttachmentCreate', ticketAttachmentCreate)
            const localVarPath = `/ticket-attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketAttachmentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a ticket note
         * @param {TicketNoteCreate} ticketNoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketNote: async (ticketNoteCreate: TicketNoteCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketNoteCreate' is not null or undefined
            assertParamExists('createTicketNote', 'ticketNoteCreate', ticketNoteCreate)
            const localVarPath = `/ticket-notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketNoteCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a ticket tag
         * @param {TicketTagCreate} ticketTagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTag: async (ticketTagCreate: TicketTagCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketTagCreate' is not null or undefined
            assertParamExists('createTicketTag', 'ticketTagCreate', ticketTagCreate)
            const localVarPath = `/ticket-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketTagCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketAttachment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicketAttachment', 'id', id)
            const localVarPath = `/ticket-attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketNote: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicketNote', 'id', id)
            const localVarPath = `/ticket-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketTag: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicketTag', 'id', id)
            const localVarPath = `/ticket-tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketAttachment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTicketAttachment', 'id', id)
            const localVarPath = `/ticket-attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketNote: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTicketNote', 'id', id)
            const localVarPath = `/ticket-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTag: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTicketTag', 'id', id)
            const localVarPath = `/ticket-tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List ticket attachments
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketAttachments: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ticket-attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List ticket notes
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketNotes: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ticket-notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List ticket tags
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketTags: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ticket-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {TicketAttachmentUpdate} ticketAttachmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketAttachment: async (id: string, ticketAttachmentUpdate: TicketAttachmentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicketAttachment', 'id', id)
            // verify required parameter 'ticketAttachmentUpdate' is not null or undefined
            assertParamExists('updateTicketAttachment', 'ticketAttachmentUpdate', ticketAttachmentUpdate)
            const localVarPath = `/ticket-attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketAttachmentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {TicketNoteUpdate} ticketNoteUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketNote: async (id: string, ticketNoteUpdate: TicketNoteUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicketNote', 'id', id)
            // verify required parameter 'ticketNoteUpdate' is not null or undefined
            assertParamExists('updateTicketNote', 'ticketNoteUpdate', ticketNoteUpdate)
            const localVarPath = `/ticket-notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketNoteUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {TicketTagUpdate} ticketTagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTag: async (id: string, ticketTagUpdate: TicketTagUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicketTag', 'id', id)
            // verify required parameter 'ticketTagUpdate' is not null or undefined
            assertParamExists('updateTicketTag', 'ticketTagUpdate', ticketTagUpdate)
            const localVarPath = `/ticket-tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketTagUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketMetaApi - functional programming interface
 * @export
 */
export const TicketMetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketMetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ticket attachment
         * @param {TicketAttachmentCreate} ticketAttachmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketAttachment(ticketAttachmentCreate: TicketAttachmentCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketAttachment(ticketAttachmentCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.createTicketAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a ticket note
         * @param {TicketNoteCreate} ticketNoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketNote(ticketNoteCreate: TicketNoteCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketNote(ticketNoteCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.createTicketNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a ticket tag
         * @param {TicketTagCreate} ticketTagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketTag(ticketTagCreate: TicketTagCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketTag(ticketTagCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.createTicketTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicketAttachment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicketAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.deleteTicketAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicketNote(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicketNote(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.deleteTicketNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicketTag(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicketTag(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.deleteTicketTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketAttachment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.getTicketAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketNote(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketNote(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.getTicketNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketTag(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketTag(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.getTicketTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List ticket attachments
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTicketAttachments(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketAttachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTicketAttachments(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.listTicketAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List ticket notes
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTicketNotes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketNote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTicketNotes(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.listTicketNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List ticket tags
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTicketTags(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTicketTags(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.listTicketTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {TicketAttachmentUpdate} ticketAttachmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicketAttachment(id: string, ticketAttachmentUpdate: TicketAttachmentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicketAttachment(id, ticketAttachmentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.updateTicketAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {TicketNoteUpdate} ticketNoteUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicketNote(id: string, ticketNoteUpdate: TicketNoteUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicketNote(id, ticketNoteUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.updateTicketNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {TicketTagUpdate} ticketTagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicketTag(id: string, ticketTagUpdate: TicketTagUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicketTag(id, ticketTagUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketMetaApi.updateTicketTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TicketMetaApi - factory interface
 * @export
 */
export const TicketMetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketMetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ticket attachment
         * @param {TicketAttachmentCreate} ticketAttachmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketAttachment(ticketAttachmentCreate: TicketAttachmentCreate, options?: RawAxiosRequestConfig): AxiosPromise<TicketAttachment> {
            return localVarFp.createTicketAttachment(ticketAttachmentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a ticket note
         * @param {TicketNoteCreate} ticketNoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketNote(ticketNoteCreate: TicketNoteCreate, options?: RawAxiosRequestConfig): AxiosPromise<TicketNote> {
            return localVarFp.createTicketNote(ticketNoteCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a ticket tag
         * @param {TicketTagCreate} ticketTagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTag(ticketTagCreate: TicketTagCreate, options?: RawAxiosRequestConfig): AxiosPromise<TicketTag> {
            return localVarFp.createTicketTag(ticketTagCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketAttachment(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTicketAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketNote(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTicketNote(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketTag(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTicketTag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketAttachment(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TicketAttachment> {
            return localVarFp.getTicketAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketNote(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TicketNote> {
            return localVarFp.getTicketNote(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTag(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TicketTag> {
            return localVarFp.getTicketTag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List ticket attachments
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketAttachments(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TicketAttachment>> {
            return localVarFp.listTicketAttachments(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List ticket notes
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketNotes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TicketNote>> {
            return localVarFp.listTicketNotes(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List ticket tags
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketTags(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TicketTag>> {
            return localVarFp.listTicketTags(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a ticket attachment by ID
         * @param {string} id UUID of the resource
         * @param {TicketAttachmentUpdate} ticketAttachmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketAttachment(id: string, ticketAttachmentUpdate: TicketAttachmentUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TicketAttachment> {
            return localVarFp.updateTicketAttachment(id, ticketAttachmentUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a ticket note by ID
         * @param {string} id UUID of the resource
         * @param {TicketNoteUpdate} ticketNoteUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketNote(id: string, ticketNoteUpdate: TicketNoteUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TicketNote> {
            return localVarFp.updateTicketNote(id, ticketNoteUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a ticket tag by ID
         * @param {string} id UUID of the resource
         * @param {TicketTagUpdate} ticketTagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTag(id: string, ticketTagUpdate: TicketTagUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TicketTag> {
            return localVarFp.updateTicketTag(id, ticketTagUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketMetaApi - object-oriented interface
 * @export
 * @class TicketMetaApi
 * @extends {BaseAPI}
 */
export class TicketMetaApi extends BaseAPI {
    /**
     * 
     * @summary Create a ticket attachment
     * @param {TicketAttachmentCreate} ticketAttachmentCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public createTicketAttachment(ticketAttachmentCreate: TicketAttachmentCreate, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).createTicketAttachment(ticketAttachmentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a ticket note
     * @param {TicketNoteCreate} ticketNoteCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public createTicketNote(ticketNoteCreate: TicketNoteCreate, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).createTicketNote(ticketNoteCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a ticket tag
     * @param {TicketTagCreate} ticketTagCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public createTicketTag(ticketTagCreate: TicketTagCreate, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).createTicketTag(ticketTagCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a ticket attachment by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public deleteTicketAttachment(id: string, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).deleteTicketAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a ticket note by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public deleteTicketNote(id: string, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).deleteTicketNote(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a ticket tag by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public deleteTicketTag(id: string, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).deleteTicketTag(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a ticket attachment by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public getTicketAttachment(id: string, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).getTicketAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a ticket note by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public getTicketNote(id: string, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).getTicketNote(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a ticket tag by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public getTicketTag(id: string, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).getTicketTag(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List ticket attachments
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public listTicketAttachments(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).listTicketAttachments(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List ticket notes
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public listTicketNotes(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).listTicketNotes(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List ticket tags
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public listTicketTags(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).listTicketTags(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a ticket attachment by ID
     * @param {string} id UUID of the resource
     * @param {TicketAttachmentUpdate} ticketAttachmentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public updateTicketAttachment(id: string, ticketAttachmentUpdate: TicketAttachmentUpdate, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).updateTicketAttachment(id, ticketAttachmentUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a ticket note by ID
     * @param {string} id UUID of the resource
     * @param {TicketNoteUpdate} ticketNoteUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public updateTicketNote(id: string, ticketNoteUpdate: TicketNoteUpdate, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).updateTicketNote(id, ticketNoteUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a ticket tag by ID
     * @param {string} id UUID of the resource
     * @param {TicketTagUpdate} ticketTagUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketMetaApi
     */
    public updateTicketTag(id: string, ticketTagUpdate: TicketTagUpdate, options?: RawAxiosRequestConfig) {
        return TicketMetaApiFp(this.configuration).updateTicketTag(id, ticketTagUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new ticket
         * @param {TicketCreate} ticketCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (ticketCreate: TicketCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketCreate' is not null or undefined
            assertParamExists('createTicket', 'ticketCreate', ticketCreate)
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a ticket by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicket', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a ticket by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTicket', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tickets
         * @param {TicketStatus} [status] Filter by ticket status
         * @param {TicketPriority} [priority] Filter by ticket priority
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets: async (status?: TicketStatus, priority?: TicketPriority, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a ticket by ID
         * @param {string} id UUID of the resource
         * @param {TicketUpdate} ticketUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket: async (id: string, ticketUpdate: TicketUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicket', 'id', id)
            // verify required parameter 'ticketUpdate' is not null or undefined
            assertParamExists('updateTicket', 'ticketUpdate', ticketUpdate)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new ticket
         * @param {TicketCreate} ticketCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(ticketCreate: TicketCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(ticketCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketsApi.createTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a ticket by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketsApi.deleteTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a ticket by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketsApi.getTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tickets
         * @param {TicketStatus} [status] Filter by ticket status
         * @param {TicketPriority} [priority] Filter by ticket priority
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickets(status?: TicketStatus, priority?: TicketPriority, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickets(status, priority, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketsApi.listTickets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a ticket by ID
         * @param {string} id UUID of the resource
         * @param {TicketUpdate} ticketUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicket(id: string, ticketUpdate: TicketUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicket(id, ticketUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TicketsApi.updateTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new ticket
         * @param {TicketCreate} ticketCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(ticketCreate: TicketCreate, options?: RawAxiosRequestConfig): AxiosPromise<Ticket> {
            return localVarFp.createTicket(ticketCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a ticket by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTicket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a ticket by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Ticket> {
            return localVarFp.getTicket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tickets
         * @param {TicketStatus} [status] Filter by ticket status
         * @param {TicketPriority} [priority] Filter by ticket priority
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets(status?: TicketStatus, priority?: TicketPriority, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Ticket>> {
            return localVarFp.listTickets(status, priority, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a ticket by ID
         * @param {string} id UUID of the resource
         * @param {TicketUpdate} ticketUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(id: string, ticketUpdate: TicketUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Ticket> {
            return localVarFp.updateTicket(id, ticketUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new ticket
     * @param {TicketCreate} ticketCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public createTicket(ticketCreate: TicketCreate, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).createTicket(ticketCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a ticket by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public deleteTicket(id: string, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).deleteTicket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a ticket by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicket(id: string, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tickets
     * @param {TicketStatus} [status] Filter by ticket status
     * @param {TicketPriority} [priority] Filter by ticket priority
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public listTickets(status?: TicketStatus, priority?: TicketPriority, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).listTickets(status, priority, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a ticket by ID
     * @param {string} id UUID of the resource
     * @param {TicketUpdate} ticketUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public updateTicket(id: string, ticketUpdate: TicketUpdate, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).updateTicket(id, ticketUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUser', 'userCreate', userCreate)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user by ID
         * @param {string} id UUID of the resource
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUser', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a user by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List users
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user by ID
         * @param {string} id UUID of the resource
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createUser(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user by ID
         * @param {string} id UUID of the resource
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(id, userUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new user
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user by ID
     * @param {string} id UUID of the resource
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VolunteerMetaApi - axios parameter creator
 * @export
 */
export const VolunteerMetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create volunteer availability time
         * @param {VolunteerAvailabilityTimeCreate} volunteerAvailabilityTimeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteerAvailabilityTime: async (volunteerAvailabilityTimeCreate: VolunteerAvailabilityTimeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volunteerAvailabilityTimeCreate' is not null or undefined
            assertParamExists('createVolunteerAvailabilityTime', 'volunteerAvailabilityTimeCreate', volunteerAvailabilityTimeCreate)
            const localVarPath = `/volunteer-availability-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerAvailabilityTimeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create volunteer availability zone
         * @param {VolunteerAvailabilityZoneCreate} volunteerAvailabilityZoneCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteerAvailabilityZone: async (volunteerAvailabilityZoneCreate: VolunteerAvailabilityZoneCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volunteerAvailabilityZoneCreate' is not null or undefined
            assertParamExists('createVolunteerAvailabilityZone', 'volunteerAvailabilityZoneCreate', volunteerAvailabilityZoneCreate)
            const localVarPath = `/volunteer-availability-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerAvailabilityZoneCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create volunteer skill
         * @param {VolunteerSkillCreate} volunteerSkillCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteerSkill: async (volunteerSkillCreate: VolunteerSkillCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volunteerSkillCreate' is not null or undefined
            assertParamExists('createVolunteerSkill', 'volunteerSkillCreate', volunteerSkillCreate)
            const localVarPath = `/volunteer-skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerSkillCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteerAvailabilityTime: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVolunteerAvailabilityTime', 'id', id)
            const localVarPath = `/volunteer-availability-time/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteerAvailabilityZone: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVolunteerAvailabilityZone', 'id', id)
            const localVarPath = `/volunteer-availability-zones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteerSkill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVolunteerSkill', 'id', id)
            const localVarPath = `/volunteer-skills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteerAvailabilityTime: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVolunteerAvailabilityTime', 'id', id)
            const localVarPath = `/volunteer-availability-time/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteerAvailabilityZone: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVolunteerAvailabilityZone', 'id', id)
            const localVarPath = `/volunteer-availability-zones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteerSkill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVolunteerSkill', 'id', id)
            const localVarPath = `/volunteer-skills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List volunteer availability times
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteerAvailabilityTimes: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/volunteer-availability-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List volunteer availability zones
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteerAvailabilityZones: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/volunteer-availability-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List volunteer skills
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteerSkills: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/volunteer-skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerAvailabilityTimeUpdate} volunteerAvailabilityTimeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteerAvailabilityTime: async (id: string, volunteerAvailabilityTimeUpdate: VolunteerAvailabilityTimeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVolunteerAvailabilityTime', 'id', id)
            // verify required parameter 'volunteerAvailabilityTimeUpdate' is not null or undefined
            assertParamExists('updateVolunteerAvailabilityTime', 'volunteerAvailabilityTimeUpdate', volunteerAvailabilityTimeUpdate)
            const localVarPath = `/volunteer-availability-time/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerAvailabilityTimeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerAvailabilityZoneUpdate} volunteerAvailabilityZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteerAvailabilityZone: async (id: string, volunteerAvailabilityZoneUpdate: VolunteerAvailabilityZoneUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVolunteerAvailabilityZone', 'id', id)
            // verify required parameter 'volunteerAvailabilityZoneUpdate' is not null or undefined
            assertParamExists('updateVolunteerAvailabilityZone', 'volunteerAvailabilityZoneUpdate', volunteerAvailabilityZoneUpdate)
            const localVarPath = `/volunteer-availability-zones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerAvailabilityZoneUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerSkillUpdate} volunteerSkillUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteerSkill: async (id: string, volunteerSkillUpdate: VolunteerSkillUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVolunteerSkill', 'id', id)
            // verify required parameter 'volunteerSkillUpdate' is not null or undefined
            assertParamExists('updateVolunteerSkill', 'volunteerSkillUpdate', volunteerSkillUpdate)
            const localVarPath = `/volunteer-skills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerSkillUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolunteerMetaApi - functional programming interface
 * @export
 */
export const VolunteerMetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VolunteerMetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create volunteer availability time
         * @param {VolunteerAvailabilityTimeCreate} volunteerAvailabilityTimeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolunteerAvailabilityTime(volunteerAvailabilityTimeCreate: VolunteerAvailabilityTimeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerAvailabilityTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolunteerAvailabilityTime(volunteerAvailabilityTimeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.createVolunteerAvailabilityTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create volunteer availability zone
         * @param {VolunteerAvailabilityZoneCreate} volunteerAvailabilityZoneCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolunteerAvailabilityZone(volunteerAvailabilityZoneCreate: VolunteerAvailabilityZoneCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerAvailabilityZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolunteerAvailabilityZone(volunteerAvailabilityZoneCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.createVolunteerAvailabilityZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create volunteer skill
         * @param {VolunteerSkillCreate} volunteerSkillCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolunteerSkill(volunteerSkillCreate: VolunteerSkillCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolunteerSkill(volunteerSkillCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.createVolunteerSkill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolunteerAvailabilityTime(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolunteerAvailabilityTime(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.deleteVolunteerAvailabilityTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolunteerAvailabilityZone(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolunteerAvailabilityZone(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.deleteVolunteerAvailabilityZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolunteerSkill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolunteerSkill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.deleteVolunteerSkill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolunteerAvailabilityTime(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerAvailabilityTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolunteerAvailabilityTime(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.getVolunteerAvailabilityTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolunteerAvailabilityZone(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerAvailabilityZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolunteerAvailabilityZone(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.getVolunteerAvailabilityZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolunteerSkill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolunteerSkill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.getVolunteerSkill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List volunteer availability times
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolunteerAvailabilityTimes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VolunteerAvailabilityTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolunteerAvailabilityTimes(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.listVolunteerAvailabilityTimes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List volunteer availability zones
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolunteerAvailabilityZones(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VolunteerAvailabilityZone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolunteerAvailabilityZones(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.listVolunteerAvailabilityZones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List volunteer skills
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolunteerSkills(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VolunteerSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolunteerSkills(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.listVolunteerSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerAvailabilityTimeUpdate} volunteerAvailabilityTimeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolunteerAvailabilityTime(id: string, volunteerAvailabilityTimeUpdate: VolunteerAvailabilityTimeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerAvailabilityTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolunteerAvailabilityTime(id, volunteerAvailabilityTimeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.updateVolunteerAvailabilityTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerAvailabilityZoneUpdate} volunteerAvailabilityZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolunteerAvailabilityZone(id: string, volunteerAvailabilityZoneUpdate: VolunteerAvailabilityZoneUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerAvailabilityZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolunteerAvailabilityZone(id, volunteerAvailabilityZoneUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.updateVolunteerAvailabilityZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerSkillUpdate} volunteerSkillUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolunteerSkill(id: string, volunteerSkillUpdate: VolunteerSkillUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolunteerSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolunteerSkill(id, volunteerSkillUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteerMetaApi.updateVolunteerSkill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VolunteerMetaApi - factory interface
 * @export
 */
export const VolunteerMetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VolunteerMetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Create volunteer availability time
         * @param {VolunteerAvailabilityTimeCreate} volunteerAvailabilityTimeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteerAvailabilityTime(volunteerAvailabilityTimeCreate: VolunteerAvailabilityTimeCreate, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerAvailabilityTime> {
            return localVarFp.createVolunteerAvailabilityTime(volunteerAvailabilityTimeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create volunteer availability zone
         * @param {VolunteerAvailabilityZoneCreate} volunteerAvailabilityZoneCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteerAvailabilityZone(volunteerAvailabilityZoneCreate: VolunteerAvailabilityZoneCreate, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerAvailabilityZone> {
            return localVarFp.createVolunteerAvailabilityZone(volunteerAvailabilityZoneCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create volunteer skill
         * @param {VolunteerSkillCreate} volunteerSkillCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteerSkill(volunteerSkillCreate: VolunteerSkillCreate, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerSkill> {
            return localVarFp.createVolunteerSkill(volunteerSkillCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteerAvailabilityTime(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVolunteerAvailabilityTime(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteerAvailabilityZone(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVolunteerAvailabilityZone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteerSkill(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVolunteerSkill(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteerAvailabilityTime(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerAvailabilityTime> {
            return localVarFp.getVolunteerAvailabilityTime(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteerAvailabilityZone(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerAvailabilityZone> {
            return localVarFp.getVolunteerAvailabilityZone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteerSkill(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerSkill> {
            return localVarFp.getVolunteerSkill(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List volunteer availability times
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteerAvailabilityTimes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VolunteerAvailabilityTime>> {
            return localVarFp.listVolunteerAvailabilityTimes(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List volunteer availability zones
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteerAvailabilityZones(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VolunteerAvailabilityZone>> {
            return localVarFp.listVolunteerAvailabilityZones(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List volunteer skills
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteerSkills(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VolunteerSkill>> {
            return localVarFp.listVolunteerSkills(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a volunteer availability time by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerAvailabilityTimeUpdate} volunteerAvailabilityTimeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteerAvailabilityTime(id: string, volunteerAvailabilityTimeUpdate: VolunteerAvailabilityTimeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerAvailabilityTime> {
            return localVarFp.updateVolunteerAvailabilityTime(id, volunteerAvailabilityTimeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a volunteer availability zone by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerAvailabilityZoneUpdate} volunteerAvailabilityZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteerAvailabilityZone(id: string, volunteerAvailabilityZoneUpdate: VolunteerAvailabilityZoneUpdate, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerAvailabilityZone> {
            return localVarFp.updateVolunteerAvailabilityZone(id, volunteerAvailabilityZoneUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a volunteer skill by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerSkillUpdate} volunteerSkillUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteerSkill(id: string, volunteerSkillUpdate: VolunteerSkillUpdate, options?: RawAxiosRequestConfig): AxiosPromise<VolunteerSkill> {
            return localVarFp.updateVolunteerSkill(id, volunteerSkillUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VolunteerMetaApi - object-oriented interface
 * @export
 * @class VolunteerMetaApi
 * @extends {BaseAPI}
 */
export class VolunteerMetaApi extends BaseAPI {
    /**
     * 
     * @summary Create volunteer availability time
     * @param {VolunteerAvailabilityTimeCreate} volunteerAvailabilityTimeCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public createVolunteerAvailabilityTime(volunteerAvailabilityTimeCreate: VolunteerAvailabilityTimeCreate, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).createVolunteerAvailabilityTime(volunteerAvailabilityTimeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create volunteer availability zone
     * @param {VolunteerAvailabilityZoneCreate} volunteerAvailabilityZoneCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public createVolunteerAvailabilityZone(volunteerAvailabilityZoneCreate: VolunteerAvailabilityZoneCreate, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).createVolunteerAvailabilityZone(volunteerAvailabilityZoneCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create volunteer skill
     * @param {VolunteerSkillCreate} volunteerSkillCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public createVolunteerSkill(volunteerSkillCreate: VolunteerSkillCreate, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).createVolunteerSkill(volunteerSkillCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a volunteer availability time by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public deleteVolunteerAvailabilityTime(id: string, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).deleteVolunteerAvailabilityTime(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a volunteer availability zone by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public deleteVolunteerAvailabilityZone(id: string, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).deleteVolunteerAvailabilityZone(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a volunteer skill by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public deleteVolunteerSkill(id: string, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).deleteVolunteerSkill(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a volunteer availability time by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public getVolunteerAvailabilityTime(id: string, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).getVolunteerAvailabilityTime(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a volunteer availability zone by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public getVolunteerAvailabilityZone(id: string, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).getVolunteerAvailabilityZone(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a volunteer skill by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public getVolunteerSkill(id: string, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).getVolunteerSkill(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List volunteer availability times
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public listVolunteerAvailabilityTimes(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).listVolunteerAvailabilityTimes(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List volunteer availability zones
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public listVolunteerAvailabilityZones(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).listVolunteerAvailabilityZones(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List volunteer skills
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public listVolunteerSkills(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).listVolunteerSkills(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a volunteer availability time by ID
     * @param {string} id UUID of the resource
     * @param {VolunteerAvailabilityTimeUpdate} volunteerAvailabilityTimeUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public updateVolunteerAvailabilityTime(id: string, volunteerAvailabilityTimeUpdate: VolunteerAvailabilityTimeUpdate, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).updateVolunteerAvailabilityTime(id, volunteerAvailabilityTimeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a volunteer availability zone by ID
     * @param {string} id UUID of the resource
     * @param {VolunteerAvailabilityZoneUpdate} volunteerAvailabilityZoneUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public updateVolunteerAvailabilityZone(id: string, volunteerAvailabilityZoneUpdate: VolunteerAvailabilityZoneUpdate, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).updateVolunteerAvailabilityZone(id, volunteerAvailabilityZoneUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a volunteer skill by ID
     * @param {string} id UUID of the resource
     * @param {VolunteerSkillUpdate} volunteerSkillUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteerMetaApi
     */
    public updateVolunteerSkill(id: string, volunteerSkillUpdate: VolunteerSkillUpdate, options?: RawAxiosRequestConfig) {
        return VolunteerMetaApiFp(this.configuration).updateVolunteerSkill(id, volunteerSkillUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VolunteersApi - axios parameter creator
 * @export
 */
export const VolunteersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new volunteer
         * @param {VolunteerCreate} volunteerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteer: async (volunteerCreate: VolunteerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volunteerCreate' is not null or undefined
            assertParamExists('createVolunteer', 'volunteerCreate', volunteerCreate)
            const localVarPath = `/volunteers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVolunteer', 'id', id)
            const localVarPath = `/volunteers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVolunteer', 'id', id)
            const localVarPath = `/volunteers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List volunteers
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteers: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/volunteers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerUpdate} volunteerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteer: async (id: string, volunteerUpdate: VolunteerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVolunteer', 'id', id)
            // verify required parameter 'volunteerUpdate' is not null or undefined
            assertParamExists('updateVolunteer', 'volunteerUpdate', volunteerUpdate)
            const localVarPath = `/volunteers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volunteerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolunteersApi - functional programming interface
 * @export
 */
export const VolunteersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VolunteersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new volunteer
         * @param {VolunteerCreate} volunteerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolunteer(volunteerCreate: VolunteerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volunteer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolunteer(volunteerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteersApi.createVolunteer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolunteer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolunteer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteersApi.deleteVolunteer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolunteer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volunteer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolunteer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteersApi.getVolunteer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List volunteers
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolunteers(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Volunteer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolunteers(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteersApi.listVolunteers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerUpdate} volunteerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolunteer(id: string, volunteerUpdate: VolunteerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volunteer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolunteer(id, volunteerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolunteersApi.updateVolunteer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VolunteersApi - factory interface
 * @export
 */
export const VolunteersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VolunteersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new volunteer
         * @param {VolunteerCreate} volunteerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolunteer(volunteerCreate: VolunteerCreate, options?: RawAxiosRequestConfig): AxiosPromise<Volunteer> {
            return localVarFp.createVolunteer(volunteerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolunteer(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVolunteer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteer(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Volunteer> {
            return localVarFp.getVolunteer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List volunteers
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip before starting to collect results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolunteers(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Volunteer>> {
            return localVarFp.listVolunteers(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a volunteer by ID
         * @param {string} id UUID of the resource
         * @param {VolunteerUpdate} volunteerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolunteer(id: string, volunteerUpdate: VolunteerUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Volunteer> {
            return localVarFp.updateVolunteer(id, volunteerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VolunteersApi - object-oriented interface
 * @export
 * @class VolunteersApi
 * @extends {BaseAPI}
 */
export class VolunteersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new volunteer
     * @param {VolunteerCreate} volunteerCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteersApi
     */
    public createVolunteer(volunteerCreate: VolunteerCreate, options?: RawAxiosRequestConfig) {
        return VolunteersApiFp(this.configuration).createVolunteer(volunteerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a volunteer by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteersApi
     */
    public deleteVolunteer(id: string, options?: RawAxiosRequestConfig) {
        return VolunteersApiFp(this.configuration).deleteVolunteer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a volunteer by ID
     * @param {string} id UUID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteersApi
     */
    public getVolunteer(id: string, options?: RawAxiosRequestConfig) {
        return VolunteersApiFp(this.configuration).getVolunteer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List volunteers
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip before starting to collect results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteersApi
     */
    public listVolunteers(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return VolunteersApiFp(this.configuration).listVolunteers(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a volunteer by ID
     * @param {string} id UUID of the resource
     * @param {VolunteerUpdate} volunteerUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolunteersApi
     */
    public updateVolunteer(id: string, volunteerUpdate: VolunteerUpdate, options?: RawAxiosRequestConfig) {
        return VolunteersApiFp(this.configuration).updateVolunteer(id, volunteerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



